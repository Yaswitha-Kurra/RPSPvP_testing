"{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"MatchResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum RPSPvP.Move\",\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"MoveSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"}],\"name\":\"PlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"RoomCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"createRoom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"getRoom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"internalType\":\"enum RPSPvP.Move\",\"name\":\"move1\",\"type\":\"uint8\"},{\"internalType\":\"enum RPSPvP.Move\",\"name\":\"move2\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"enum RPSPvP.RoomState\",\"name\":\"state\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"joinRoom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roomCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rooms\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"internalType\":\"enum RPSPvP.Move\",\"name\":\"move1\",\"type\":\"uint8\"},{\"internalType\":\"enum RPSPvP.Move\",\"name\":\"move2\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"enum RPSPvP.RoomState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"player1Paid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"player2Paid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"moveStr\",\"type\":\"string\"}],\"name\":\"submitMove\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RPSPvP.sol\":\"RPSPvP\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/RPSPvP.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ncontract RPSPvP {\\n    enum Move { None, Rock, Paper, Scissors }\\n    enum RoomState { WaitingForPlayer, ReadyToPlay, Completed }\\n\\n    struct Room {\\n        address player1;\\n        address player2;\\n        Move move1;\\n        Move move2;\\n        uint256 stake;\\n        RoomState state;\\n        bool player1Paid;\\n        bool player2Paid;\\n    }\\n\\n    address public owner;\\n    uint256 public roomCounter;\\n    uint256 public ownerFeePercent = 5;\\n\\n    mapping(uint256 => Room) public rooms;\\n\\n    event RoomCreated(uint256 indexed roomId, address indexed player1, uint256 stake);\\n    event PlayerJoined(uint256 indexed roomId, address indexed player2);\\n    event MoveSubmitted(uint256 indexed roomId, address indexed player, Move move);\\n    event MatchResolved(uint256 indexed roomId, address winner, uint256 reward);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyPlayers(uint256 roomId) {\\n        require(\\n            msg.sender == rooms[roomId].player1 || msg.sender == rooms[roomId].player2,\\n            \\\"Not a player in this room\\\"\\n        );\\n        _;\\n    }\\n\\n    function createRoom(uint256 stake) external returns (uint256 roomId) {\\n        require(stake > 0, \\\"Stake must be greater than 0\\\");\\n\\n        roomCounter++;\\n        rooms[roomCounter] = Room({\\n            player1: msg.sender,\\n            player2: address(0),\\n            move1: Move.None,\\n            move2: Move.None,\\n            stake: stake,\\n            state: RoomState.WaitingForPlayer,\\n            player1Paid: false,\\n            player2Paid: false\\n        });\\n\\n        emit RoomCreated(roomCounter, msg.sender, stake);\\n        return roomCounter;\\n    }\\n\\n    function joinRoom(uint256 roomId) external {\\n        Room storage room = rooms[roomId];\\n        require(room.state == RoomState.WaitingForPlayer, \\\"Room not available\\\");\\n        require(msg.sender != room.player1, \\\"You cannot join your own room\\\");\\n\\n        room.player2 = msg.sender;\\n        room.state = RoomState.ReadyToPlay;\\n\\n        emit PlayerJoined(roomId, msg.sender);\\n    }\\n\\n    function submitMove(uint256 roomId, string calldata moveStr) external payable onlyPlayers(roomId) {\\n        Room storage room = rooms[roomId];\\n        require(room.state == RoomState.ReadyToPlay, \\\"Room not ready\\\");\\n\\n        Move move = _parseMove(moveStr);\\n        require(move != Move.None, \\\"Invalid move\\\");\\n        require(msg.value == room.stake, \\\"Incorrect stake amount\\\");\\n\\n        if (msg.sender == room.player1) {\\n            require(!room.player1Paid, \\\"Move already submitted\\\");\\n            room.move1 = move;\\n            room.player1Paid = true;\\n        } else {\\n            require(!room.player2Paid, \\\"Move already submitted\\\");\\n            room.move2 = move;\\n            room.player2Paid = true;\\n        }\\n\\n        emit MoveSubmitted(roomId, msg.sender, move);\\n\\n        if (room.player1Paid && room.player2Paid) {\\n            _resolveMatch(roomId);\\n        }\\n    }\\n\\n    function _resolveMatch(uint256 roomId) internal {\\n        Room storage room = rooms[roomId];\\n        room.state = RoomState.Completed;\\n\\n        address payable winner;\\n        uint256 totalPool = room.stake * 2;\\n        uint256 fee = (totalPool * ownerFeePercent) / 100;\\n        uint256 reward = totalPool - fee;\\n\\n        if (room.move1 == room.move2) {\\n            // Draw: refund both\\n            payable(room.player1).transfer(room.stake);\\n            payable(room.player2).transfer(room.stake);\\n            emit MatchResolved(roomId, address(0), 0);\\n            return;\\n        }\\n\\n        if (_beats(room.move1, room.move2)) {\\n            winner = payable(room.player1);\\n        } else {\\n            winner = payable(room.player2);\\n        }\\n\\n        // Transfer reward to winner\\n        (bool sent, ) = winner.call{value: reward}(\\\"\\\");\\n        require(sent, \\\"Reward transfer failed\\\");\\n\\n        // Transfer fee to owner\\n        (bool feeSent, ) = payable(owner).call{value: fee}(\\\"\\\");\\n        require(feeSent, \\\"Owner fee transfer failed\\\");\\n\\n        emit MatchResolved(roomId, winner, reward);\\n    }\\n\\n    function _parseMove(string memory moveStr) internal pure returns (Move) {\\n        bytes32 h = keccak256(abi.encodePacked(moveStr));\\n        if (h == keccak256(abi.encodePacked(\\\"rock\\\"))) return Move.Rock;\\n        if (h == keccak256(abi.encodePacked(\\\"paper\\\"))) return Move.Paper;\\n        if (h == keccak256(abi.encodePacked(\\\"scissors\\\"))) return Move.Scissors;\\n        return Move.None;\\n    }\\n\\n    function _beats(Move a, Move b) internal pure returns (bool) {\\n        return (a == Move.Rock && b == Move.Scissors) ||\\n               (a == Move.Paper && b == Move.Rock) ||\\n               (a == Move.Scissors && b == Move.Paper);\\n    }\\n\\n    function getRoom(uint256 roomId) external view returns (\\n        address player1,\\n        address player2,\\n        Move move1,\\n        Move move2,\\n        uint256 stake,\\n        RoomState state\\n    ) {\\n        Room storage r = rooms[roomId];\\n        return (r.player1, r.player2, r.move1, r.move2, r.stake, r.state);\\n    }\\n}\\n\",\"keccak256\":\"0xcccc1da09d5aba378fb0ea347dfa1da8c9aef624d7dfc0be4b8f4bd7dd215f94\",\"license\":\"MIT\"}},\"version\":1}"